@page "/"
@rendermode InteractiveServer
@using System.Security.Claims
@using Microsoft.AspNetCore.Components.Authorization
@using Microsoft.EntityFrameworkCore
@using SkiaSharp
@using WaxMapArt.Comparison
@using WaxMapArt.Dithering
@using WaxMapArt.Exporter
@using WaxMapArt.Generator
@using WaxMapArt.Web.Components.Components
@inject NavigationManager NavigationManager
@inject IDbContextFactory<DatabaseContext> DbContextFactory
@inject AuthenticationStateProvider AuthenticationStateProvider

<PageTitle>Home</PageTitle>

@if (_palettes is null)
{
    <p>Login to continue</p>
}
else
{
    <EditForm Model="_formModel" OnValidSubmit="OnValidSubmit" class="flex flex-col items-center space-y-4">
        <PrelineFileUpload
            @ref="_imageUpload"
            OnFilesSelected="FileUploaded"
            ShowProgressBar="true"
            MaxFileSize="Int64.MaxValue" />
        
        <div class="grid grid-cols-1 md:grid-cols-2 gap-8 w-full md:w-3/4 lg:w-1/2">
            <PrelineSelect TValue="DitheringMode"
                           @bind-SelectedValue="_formModel.DitheringMode"
                           Placeholder="Select Dithering Mode"
                           SelectOptions="@(SelectOption.FromEnum<DitheringMode>())" />
            <PrelineSelect TValue="GeneratorType"
                           @bind-SelectedValue="_formModel.GeneratorType"
                           Placeholder="Select Generator Type"
                           SelectOptions="@(SelectOption.FromEnum<GeneratorType>())" />
            <PrelineSelect TValue="ComparisonMode"
                           @bind-SelectedValue="_formModel.ComparisonMode"
                           Placeholder="Select Comparison Mode"
                           SelectOptions="@(SelectOption.FromEnum<ComparisonMode>())" />
            <PrelineSelect TValue="Palette"
                           @bind-SelectedValue="_formModel.SelectedPalette"
                           Placeholder="Select Palette"
                           SelectOptions="@(_palettes.Select(palette => new SelectOption<Palette>{ Text = palette.Name.Trim().ToLower(), Value = palette }).ToList())" />
            <PrelineSelect TValue="IExporter"
                           @bind-SelectedValue="_formModel.Exporter"
                           Placeholder="Exporter"
                           SelectOptions="_exportOptions"></PrelineSelect>
        </div>
        
        <PrelineNavCard Class="w-full md:w-3/4 lg:w-1/2 dark:bg-neutral-800">
            <PrelineNavCardTab Title="Size">
                <div class="flex flex-col space-y-4">
                    <div class="flex flex-row space-x-4">
                        <PrelineInputNumber TValue="int"
                                            @bind-Value="_formModel.WidthMultiplier"
                                            Variant="InputNumberVariant.Horizontal"
                                            Min="1"
                                            Max="16"
                                            Step="1"
                                            AriaLabel="Width">
                            <Label>Width</Label>
                        </PrelineInputNumber>
                        <PrelineInputNumber TValue="int"
                                            @bind-Value="_formModel.HeightMultiplier"
                                            Variant="InputNumberVariant.Horizontal"
                                            Min="1"
                                            Max="16"
                                            Step="1"
                                            AriaLabel="Height">
                            <Label>Height</Label>
                        </PrelineInputNumber>
                    </div>

                    <PrelineSelect TValue="ResizeMethod"
                                   @bind-SelectedValue="_formModel.ResizeMethod"
                                   Placeholder="Select resize method"
                                   SelectOptions="@(SelectOption.FromEnum<ResizeMethod>())"/>

                    @switch (_formModel.ResizeMethod)
                    {
                        case ResizeMethod.Crop:
                            <PrelineInputNumber TValue="int"
                                                @bind-Value="_formModel.CropOffsetX"
                                                Variant="InputNumberVariant.Horizontal"
                                                Step="1">
                                <Label>Cut X Offset</Label>
                            </PrelineInputNumber>
                            <PrelineInputNumber TValue="int"
                                                @bind-Value="_formModel.CropOffsetY"
                                                Variant="InputNumberVariant.Horizontal"
                                                Step="1">
                                <Label>Cut Y Offset</Label>
                            </PrelineInputNumber>
                            break;
                        case ResizeMethod.Pad:
                            <PrelineInputText @bind-Value="_formModel.PadColor"
                                              Placeholder="FillColor">
                                <Label>Fill Color</Label>
                            </PrelineInputText>
                            break;
                    }
                </div>
            </PrelineNavCardTab>
            <PrelineNavCardTab Title="Pre-Processing">
                <div class="flex flex-col gap-4">
                    <PrelineInputNumber TValue="float"
                                        @bind-Value="_formModel.Saturation"
                                        Variant="InputNumberVariant.Horizontal"
                                        Min="0.0f"
                                        Max="2.0f"
                                        Step="0.1f">
                        <Label>Saturation</Label>
                    </PrelineInputNumber>
                    <PrelineInputNumber TValue="float"
                                        @bind-Value="_formModel.Brightness"
                                        Variant="InputNumberVariant.Horizontal"
                                        Min="0.0f"
                                        Max="2.0f"
                                        Step="0.1f">
                        <Label>Brightness</Label>
                    </PrelineInputNumber>
                    <PrelineInputNumber TValue="float"
                                        @bind-Value="_formModel.Contrast"
                                        Variant="InputNumberVariant.Horizontal"
                                        Min="0.0f"
                                        Max="2.0f"
                                        Step="0.1f">
                        <Label>Contrast</Label>
                    </PrelineInputNumber>
                </div>
            </PrelineNavCardTab>
        </PrelineNavCard>
        
        <ValidationSummary />
        
        @if (_originalImageUrl is not null)
        {
            <div class="w-full md:w-3/4 lg:w-1/2 flex flex-col space-y-4">
                <div class="flex flex-row space-x-4">
                    <div class="relative w-full overflow-hidden">
                        <img src="@_originalImageUrl"
                             class="w-full h-full object-cover"
                             alt="Original image"/>
                        <PrelineBadge Variant="PrelineBadgeVariant.Soft" Color="gray-800" BackgroundColor="gray-100" Class="absolute top-4 right-4 z-10">Original</PrelineBadge>
                    </div>
                    
                    @if (_preProcessedImageUrl is not null)
                    {
                        <div class="relative w-full overflow-hidden">
                            <img src="@_preProcessedImageUrl"
                                 class="w-full h-full object-cover"
                                 alt="Pre-processed image"/>
                            <PrelineBadge Variant="PrelineBadgeVariant.Soft" Color="blue-600" BackgroundColor="blue-100" Class="absolute top-4 right-4 z-10 dark:bg-blue-800/30 dark:text-blue-400">Pre-Processed</PrelineBadge>
                        </div>
                    }
                </div>
                
                @if (_generatedImageUrl is not null)
                {
                    <div class="flex justify-center">
                        <div class="relative w-1/2 overflow-hidden">
                            <img src="@_generatedImageUrl"
                                 class="w-full h-full object-cover"
                                 alt="Generated image"/>
                            <PrelineBadge Variant="PrelineBadgeVariant.Soft" Color="teal-500" BackgroundColor="teal-100" Class="absolute top-4 right-4 z-10 dark:bg-teal-800/30 dark:text-teal-500">Generated</PrelineBadge>
                        </div>
                    </div>
                }
            </div>
        }

        <div class="flex space-x-4">
            <button type="submit" class="px-4 py-2 bg-green-600 text-white rounded" @onclick="() => _generate = false">Preview</button>
            <button type="submit" class="px-4 py-2 bg-blue-600 text-white rounded" @onclick="() => _generate = true">Generate</button>
        </div>
    </EditForm>
    
    @if (_materialList is not null && _materialList.Count > 0)
    {
        <div class="-m-1.5 overflow-x-auto mt-4">
            <div class="p-1.5 min-w-full inline-block align-middle">
                <div class="border border-gray-200 rounded-lg overflow-hidden dark:border-neutral-700">
                    <PrelineTable TItem="MapMaterial"
                                  Items="@_sortedMaterialList"
                                  TotalCount="@_materialList.Count"
                                  IsLoading="false"
                                  CurrentPage="1"
                                  PageSize="@_materialList.Count"
                                  Columns="@_materialColumns"
                                  InitialSortColumn="Count"
                                  InitialSortAscending="false"
                                  OnPageChanged="OnMaterialPageChanged"
                                  EmptyText="No materials necessary."
                                  LoadingText="Loading materials...">
                    </PrelineTable>
                </div>
            </div>
        </div>
    }
    
    
    @if (_exportUrl != null)
    {
        <a id="exportMap" class="btn" href="@_exportUrl" download="map.litematic"
           role="button" target="=_top">Download</a>
    }
}

@code {
    private DatabaseContext? _database;
    PrelineFileUpload _imageUpload = null!;

    private string? _originalImageUrl;
    private string? _preProcessedImageUrl;
    private string? _generatedImageUrl;
    private string? _exportUrl;

    private SKBitmap? _inputImage;

    private List<MapMaterial>? _materialList;
    private List<MapMaterial>? _sortedMaterialList;
    private string _materialSortColumn = "Count";
    private bool _materialSortAscending = false;

    private List<SelectOption<IExporter>> _exportOptions = [new() { Text = "Vanilla", Value = new VanillaExporter(), IsSelected = true }, new() { Text = "Litematica", Value = new LitematicaExporter() }];

    private readonly List<PrelineTable<MapMaterial>.TableColumn<MapMaterial>> _materialColumns =
    [
        new()
        {
            Header = "Block",
            PropertyName = "Block",
            Sortable = true,
            Template = material => @<div class="flex items-center space-x-2">
                                       <img src="@material.Material.ImageUrl" alt="@material.Material.MinecraftId"
                                            class="w-10 h-10 object-cover rounded-md border border-gray-300"/>
                                       <span>@material.Material.Name</span>
                                   </div>
        },
        new()
        {
            Header = "ID",
            PropertyName = "Id",
            Sortable = true,
            Template = material => @<span>@material.Material.MinecraftId</span>
        },
        new()
        {
            Header = "Count",
            PropertyName = "Count",
            Sortable = true,
            Template = material => @<span>@material.Count</span>
        }
    ];

    private List<Palette>? _palettes;
    private readonly FormModel _formModel = new();
    private bool _generate;

    protected override async Task OnInitializedAsync()
    {
        _database = await DbContextFactory.CreateDbContextAsync();

        var authState = await AuthenticationStateProvider.GetAuthenticationStateAsync();
        if (authState.User.Identity?.IsAuthenticated != true)
        {
            NavigationManager.NavigateTo("/login");
            return;
        }

        var userId = Guid.Parse(authState.User.FindFirstValue(ClaimTypes.NameIdentifier) ?? string.Empty);
        if (userId == Guid.Empty)
        {
            NavigationManager.NavigateTo("/login");
            return;
        }

        _palettes = await _database.Palettes
            .Include(p => p.Blocks)
            .Include(p => p.PlaceholderBlock)
            .Where(p => p.UserId == userId)
            .ToListAsync();

        _formModel.SetPreProcessingChangeCallback(OnPreProcessingChange);
    }

    private async Task CreateOriginalPreviewAsync()
    {
        if (_inputImage is null) return;

        var targetWidth = _formModel.WidthMultiplier * 128;
        var targetHeight = _formModel.HeightMultiplier * 128;

        using var resized = new SKBitmap(targetWidth, targetHeight, _inputImage.ColorType, _inputImage.AlphaType);
        using (var canvas = new SKCanvas(resized))
        using (var paint = new SKPaint { FilterQuality = SKFilterQuality.High, IsAntialias = true })
        {
            canvas.Clear(SKColors.Transparent);
            var srcRect = new SKRect(0, 0, _inputImage.Width, _inputImage.Height);
            var dstRect = new SKRect(0, 0, targetWidth, targetHeight);
            canvas.DrawBitmap(_inputImage, srcRect, dstRect, paint);
            canvas.Flush();
        }

        using var skImage = SKImage.FromBitmap(resized);
        using var data = skImage.Encode(SKEncodedImageFormat.Png, 100);
        _originalImageUrl = ConvertStreamToBase64Url(data.ToArray());
    }

    private async Task<SKBitmap?> ProcessImageAsync()
    {
        if (_inputImage is null)
            return null;

        var source = _inputImage;

        using var surface = SKSurface.Create(new SKImageInfo(source.Width, source.Height, source.ColorType, source.AlphaType));
        var canvas = surface.Canvas;
        using var paint = new SKPaint { IsAntialias = true };

        SKColorFilter? colorFilter = null;

        if (Math.Abs(_formModel.Saturation - 1.0f) > float.Epsilon)
        {
            var s = _formModel.Saturation;
            const float rw = 0.2126f;
            const float gw = 0.7152f;
            const float bw = 0.0722f;

            var mSat = new[]
            {
                rw * (1 - s) + s, gw * (1 - s), bw * (1 - s), 0, 0,
                rw * (1 - s), gw * (1 - s) + s, bw * (1 - s), 0, 0,
                rw * (1 - s), gw * (1 - s), bw * (1 - s) + s, 0, 0,
                0, 0, 0, 1, 0
            };

            var cfSat = SKColorFilter.CreateColorMatrix(mSat);
            colorFilter = cfSat;
        }

        if (Math.Abs(_formModel.Brightness - 1.0f) > float.Epsilon || Math.Abs(_formModel.Contrast - 1.0f) > float.Epsilon)
        {
            var brightness = _formModel.Brightness;
            var contrast = _formModel.Contrast;

            var bOffset = (brightness - 1.0f) * contrast;

            var mCombined = new[]
            {
                contrast, 0, 0, 0, bOffset,
                0, contrast, 0, 0, bOffset,
                0, 0, contrast, 0, bOffset,
                0, 0, 0, 1, 0
            };

            var cfCombined = SKColorFilter.CreateColorMatrix(mCombined);
            colorFilter = colorFilter is null ? cfCombined : SKColorFilter.CreateCompose(cfCombined, colorFilter);
        }

        canvas.Clear(SKColors.Transparent);
        if (colorFilter is not null)
        {
            paint.ColorFilter = colorFilter;
        }

        canvas.DrawBitmap(source, 0, 0, paint);
        canvas.Flush();

        var targetWidth = _formModel.WidthMultiplier * 128;
        var targetHeight = _formModel.HeightMultiplier * 128;

        using var resizeSurface = SKSurface.Create(new SKImageInfo(targetWidth, targetHeight, source.ColorType, source.AlphaType));
        var resizeCanvas = resizeSurface.Canvas;
        using var paint2 = new SKPaint { FilterQuality = SKFilterQuality.High, IsAntialias = true };

        var bg = _formModel.ResizeMethod == ResizeMethod.Pad ? ParseHexColor(_formModel.PadColor) : SKColors.Transparent;
        resizeCanvas.Clear(bg);

        var workingImg = surface.Snapshot();
        var srcRect = new SKRect(0, 0, workingImg.Width, workingImg.Height);
        SKRect dstRect;

        switch (_formModel.ResizeMethod)
        {
            case ResizeMethod.Stretch:
                dstRect = new SKRect(0, 0, targetWidth, targetHeight);
                break;

            case ResizeMethod.Crop:
            {
                var sourceAspect = (float)workingImg.Width / workingImg.Height;
                var targetAspect = (float)targetWidth / targetHeight;

                int cropWidth, cropHeight, cropX, cropY;
                if (sourceAspect > targetAspect)
                {
                    cropHeight = workingImg.Height;
                    cropWidth = (int)(workingImg.Height * targetAspect);
                    cropX = (workingImg.Width - cropWidth) / 2 + _formModel.CropOffsetX;
                    cropY = _formModel.CropOffsetY;
                }
                else
                {
                    cropWidth = workingImg.Width;
                    cropHeight = (int)(workingImg.Width / targetAspect);
                    cropX = _formModel.CropOffsetX;
                    cropY = (workingImg.Height - cropHeight) / 2 + _formModel.CropOffsetY;
                }

                cropX = Math.Max(0, Math.Min(cropX, workingImg.Width - cropWidth));
                cropY = Math.Max(0, Math.Min(cropY, workingImg.Height - cropHeight));

                srcRect = new SKRect(cropX, cropY, cropX + cropWidth, cropY + cropHeight);
                dstRect = new SKRect(0, 0, targetWidth, targetHeight);
                break;
            }

            case ResizeMethod.Pad:
            case ResizeMethod.Min:
            {
                var ratio = Math.Min((float)targetWidth / workingImg.Width, (float)targetHeight / workingImg.Height);
                var newW = workingImg.Width * ratio;
                var newH = workingImg.Height * ratio;
                var dx = (targetWidth - newW) / 2f;
                var dy = (targetHeight - newH) / 2f;
                dstRect = new SKRect(dx, dy, dx + newW, dy + newH);
                break;
            }

            case ResizeMethod.Max:
            {
                var ratio = Math.Max((float)targetWidth / workingImg.Width, (float)targetHeight / workingImg.Height);
                var newW = workingImg.Width * ratio;
                var newH = workingImg.Height * ratio;
                var dx = (targetWidth - newW) / 2f;
                var dy = (targetHeight - newH) / 2f;
                dstRect = new SKRect(dx, dy, dx + newW, dy + newH);
                break;
            }

            default:
                dstRect = new SKRect(0, 0, targetWidth, targetHeight);
                break;
        }

        resizeCanvas.DrawImage(workingImg, srcRect, dstRect, paint2);
        resizeCanvas.Flush();

        using var finalImg = resizeSurface.Snapshot();
        using var data = finalImg.Encode(SKEncodedImageFormat.Png, 100);
        _preProcessedImageUrl = ConvertStreamToBase64Url(data.ToArray());

        var result = new SKBitmap(targetWidth, targetHeight);
        finalImg.ReadPixels(result.Info, result.GetPixels(), result.Info.RowBytes, 0, 0);

        return result;
    }

    private async Task OnPreProcessingChange()
    {
        if (_inputImage is not null)
        {
            await ProcessImageAsync();
            StateHasChanged();
        }
    }

    private async Task OnValidSubmit()
    {
        if (_inputImage is null) return;
        if (_database is null) return;

        IColorComparison colorComparison = _formModel.ComparisonMode switch
        {
            ComparisonMode.Rgb => new RgbColorComparison(),
            ComparisonMode.Cie76 => new Cie76ColorComparison(),
            ComparisonMode.CieDe2000 => new CieDe2000ColorComparison(),
            _ => throw new ArgumentOutOfRangeException()
        };

        IDithering dithering = _formModel.DitheringMode switch
        {
            DitheringMode.None => new NoneDithering(),
            DitheringMode.Atkinson => new AtkinsonDithering(),
            DitheringMode.FloydSteinberg => new FloydSteinbergDithering(),
            _ => throw new ArgumentOutOfRangeException()
        };

        var palette = _formModel.SelectedPalette;
        if (palette is null) return;

        var processedImage = await ProcessImageAsync();
        if (processedImage is null) return;

        var generatedImage = dithering.ApplyDithering(processedImage, palette, colorComparison, _formModel.GeneratorType == GeneratorType.Staircase);
        using (var skImg = SKImage.FromBitmap(generatedImage))
        using (var data = skImg.Encode(SKEncodedImageFormat.Png, 100))
        {
            _generatedImageUrl = ConvertStreamToBase64Url(data.ToArray());
        }

        if (!_generate) return;

        IGenerator generator = _formModel.GeneratorType switch
        {
            GeneratorType.Flat => new FlatGenerator(),
            GeneratorType.Staircase => new StaircaseGenerator(),
            _ => throw new ArgumentOutOfRangeException()
        };
        var generatorOutput = generator.Generate(generatedImage, palette);

        _materialList = [];
        foreach (var blockGroup in generatorOutput.Blocks.GroupBy(info => info.Id))
        {
            var block = await _database.Blocks.FirstOrDefaultAsync(b => b.MinecraftId == blockGroup.Key);
            var count = blockGroup.Count();
            if (block is null) continue;

            _materialList.Add(new MapMaterial(block, count));
        }

        _sortedMaterialList = _materialList.OrderByDescending(m => m.Count).ToList();

        var outStream = _formModel.Exporter.SaveAsStream(palette, generatorOutput.Blocks);
        var outMs = new MemoryStream();
        await outStream.CopyToAsync(outMs);

        _exportUrl = ConvertStreamToBase64Url(outMs.ToArray(), "application/octet-stream");
    }

    private async Task OnMaterialPageChanged(PrelineTable<MapMaterial>.PageChangedEventArgs args)
    {
        _materialSortColumn = args.SortColumn;
        _materialSortAscending = args.SortAscending;

        if (_materialList is null) return;

        _sortedMaterialList = _materialSortColumn switch
        {
            "Count" => _materialSortAscending
                ? _materialList.OrderBy(m => m.Count).ToList()
                : _materialList.OrderByDescending(m => m.Count).ToList(),
            "Block" => _materialSortAscending
                ? _materialList.OrderBy(m => m.Material.Name).ToList()
                : _materialList.OrderByDescending(m => m.Material.Name).ToList(),
            "Id" => _materialSortAscending
                ? _materialList.OrderBy(m => m.Material.MinecraftId).ToList()
                : _materialList.OrderByDescending(m => m.Material.MinecraftId).ToList(),
            _ => _materialList
        };
    }

    private static string ConvertStreamToBase64Url(byte[] data, string contentType = "image/png") => $"data:{contentType};base64,{Convert.ToBase64String(data)}";

    private class FormModel
    {
        private float _saturation = 1.0f;
        private float _brightness = 1.0f;
        private float _contrast = 1.0f;
        private Func<Task>? _preProcessingChangeCallback;

        public DitheringMode DitheringMode { get; set; }
        public ComparisonMode ComparisonMode { get; set; }
        public GeneratorType GeneratorType { get; set; }
        public Palette? SelectedPalette { get; set; }
        public IExporter Exporter { get; set; }
        public int WidthMultiplier { get; set; } = 1;
        public int HeightMultiplier { get; set; } = 1;
        public ResizeMethod ResizeMethod { get; set; } = ResizeMethod.Crop;
        public int CropOffsetX { get; set; }
        public int CropOffsetY { get; set; }
        public string PadColor { get; set; } = "#FFFFFF";

        public float Saturation
        {
            get => _saturation;
            set
            {
                if (Math.Abs(_saturation - value) < float.Epsilon) return;
                _saturation = value;
                _preProcessingChangeCallback?.Invoke();
            }
        }

        public float Brightness
        {
            get => _brightness;
            set
            {
                if (Math.Abs(_brightness - value) < float.Epsilon) return;
                _brightness = value;
                _preProcessingChangeCallback?.Invoke();
            }
        }

        public float Contrast
        {
            get => _contrast;
            set
            {
                if (Math.Abs(_contrast - value) < float.Epsilon) return;
                _contrast = value;
                _preProcessingChangeCallback?.Invoke();
            }
        }

        public void SetPreProcessingChangeCallback(Func<Task> callback)
        {
            _preProcessingChangeCallback = callback;
        }
    }

    private enum GeneratorType
    {
        Flat,
        Staircase
    }

    private enum ResizeMethod
    {
        Stretch,
        Pad,
        Crop,
        Min,
        Max
    }

    private static SKColor ParseHexColor(string hex)
    {
        if (string.IsNullOrWhiteSpace(hex)) return SKColors.White;
        if (hex.StartsWith("#")) hex = hex[1..];
        try
        {
            switch (hex.Length)
            {
                case 6:
                {
                    var r = Convert.ToByte(hex.Substring(0, 2), 16);
                    var g = Convert.ToByte(hex.Substring(2, 2), 16);
                    var b = Convert.ToByte(hex.Substring(4, 2), 16);
                    return new SKColor(r, g, b);
                }
                case 8:
                {
                    var a = Convert.ToByte(hex.Substring(0, 2), 16);
                    var r = Convert.ToByte(hex.Substring(2, 2), 16);
                    var g = Convert.ToByte(hex.Substring(4, 2), 16);
                    var b = Convert.ToByte(hex.Substring(6, 2), 16);
                    return new SKColor(r, g, b, a);
                }
            }
        }
        catch
        {
            // ignore and fallback
        }

        return SKColors.White;
    }

    private async void FileUploaded(IBrowserFile[] obj)
    {
        var file = obj.FirstOrDefault();
        if (file is null) return;

        await using var ms = new MemoryStream();
        var stream = file.OpenReadStream(_imageUpload.MaxFileSize);
        var buffer = new byte[4096];
        int bytesRead;
        long totalRead = 0;

        while ((bytesRead = await stream.ReadAsync(buffer)) > 0)
        {
            await ms.WriteAsync(buffer.AsMemory(0, bytesRead));
            totalRead += bytesRead;
            var percentComplete = (int)((float)totalRead / stream.Length * 100);
            _imageUpload.SetFileProgress(_imageUpload.GetSelectedFiles().First(), percentComplete);
        }

        var data = ms.ToArray();
        _inputImage = SKBitmap.Decode(data);

        await CreateOriginalPreviewAsync();

        await ProcessImageAsync();

        StateHasChanged();
    }

    record struct MapMaterial(Block Material, int Count);

}