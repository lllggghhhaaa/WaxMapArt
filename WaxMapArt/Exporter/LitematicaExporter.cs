using System.IO.Compression;
using WaxMapArt.Entities;
using WaxNBT;
using WaxNBT.Tags;

namespace WaxMapArt.Exporter
{
    public class LitematicaExporter : IExporter
    {
        public Stream SaveAsStream(Palette palette, BlockInfo[] blocks)
        {
            var dimensions = CalculateDimensions(blocks);

            var metadata = CreateMetadata(dimensions, blocks.Length, dimensions.width * dimensions.height * dimensions.depth, 1);
            var blockStatePalette = CreateBlockStatePalette(palette);
            var blockStates = CreateBlockStates(blocks, dimensions, palette);

            var map = CreateMapCompound(dimensions, blockStatePalette, blockStates);
            var regions = new NbtCompound("Regions").Add(map);

            var file = new NbtFile();
            file.Root
                .Add(new NbtInt("Version", 7))
                .Add(new NbtInt("MinecraftDataVersion", 3955))
                .Add(metadata)
                .Add(regions);

            var rawStream = file.SerializeToStream();
            var ms = new MemoryStream();
            using (var gzip = new GZipStream(ms, CompressionMode.Compress, true))
            {
                rawStream.CopyTo(gzip);
                gzip.Flush();
            }
            rawStream.Close();
            rawStream.Dispose();
            ms.Seek(0, SeekOrigin.Begin);
            return ms;
        }

        private static (int width, int height, int depth) CalculateDimensions(BlockInfo[] blocks)
        {
            if (blocks.Length == 0) return (0, 0, 0);

            var minX = blocks.Min(b => b.X);
            var maxX = blocks.Max(b => b.X);
            var minY = blocks.Min(b => b.Y);
            var maxY = blocks.Max(b => b.Y);
            var minZ = blocks.Min(b => b.Z);
            var maxZ = blocks.Max(b => b.Z);

            return (maxX - minX + 1, maxY - minY + 1, maxZ - minZ + 1);
        }

        private static NbtCompound CreateMetadata((int width, int height, int depth) dimensions, int totalBlocks, int totalVolume, int regionCount)
        {
            var enclosingSize = new NbtCompound("EnclosingSize")
                .Add(new NbtInt("x", dimensions.width))
                .Add(new NbtInt("y", dimensions.height))
                .Add(new NbtInt("z", dimensions.depth));

            var timestamp = DateTimeOffset.UtcNow.ToUnixTimeMilliseconds();

            return new NbtCompound("Metadata")
                .Add(new NbtString("Name", "WaxMapArt"))
                .Add(new NbtString("Description", "Generated by WaxMapArt"))
                .Add(new NbtString("Author", "WaxMapArt"))
                .Add(enclosingSize)
                .Add(new NbtInt("RegionCount", regionCount))
                .Add(new NbtLong("TimeCreated", timestamp))
                .Add(new NbtLong("TimeModified", timestamp))
                .Add(new NbtInt("TotalBlocks", totalBlocks))
                .Add(new NbtInt("TotalVolume", totalVolume));
        }

        private static NbtList CreateBlockStatePalette(Palette palette)
        {
            var list = new NbtList("BlockStatePalette");

            var airCompound = new NbtCompound().Add(new NbtString("Name", "minecraft:air"));
            list.Add(airCompound);

            foreach (var color in palette.Colors)
            {
                if (string.IsNullOrEmpty(color.Id)) continue;

                var comp = new NbtCompound()
                    .Add(new NbtString("Name", color.Id));

                if (color.Properties.Count > 0)
                {
                    var props = new NbtCompound("Properties");
                    var hasProps = false;
                    foreach (var kv in color.Properties.OrderBy(k => k.Key))
                    {
                        if (!string.IsNullOrEmpty(kv.Key) && !string.IsNullOrEmpty(kv.Value))
                        {
                            props.Add(new NbtString(kv.Key, kv.Value));
                            hasProps = true;
                        }
                    }

                    if (hasProps)
                    {
                        comp.Add(props);
                    }
                }
                list.Add(comp);
            }
            
            return list;
        }

        private static long[] CreateBlockStates(BlockInfo[] blocks, (int width, int height, int depth) dimensions, Palette palette)
    {
        var width = dimensions.width;
        var height = dimensions.height;
        var depth = dimensions.depth;
        var totalBlocks = width * height * depth;

        var minX = blocks.Min(b => b.X);
        var minY = blocks.Min(b => b.Y);
        var minZ = blocks.Min(b => b.Z);
        var byPos = new Dictionary<(int x, int y, int z), BlockInfo>(blocks.Length);
        foreach (var b in blocks) byPos[(b.X - minX, b.Y - minY, b.Z - minZ)] = b;

        var paletteSize = palette.Colors.Length + 1;
        var bitsPerBlock = Math.Max(2, (int)Math.Ceiling(Math.Log2(paletteSize)));
        var mask = (1UL << bitsPerBlock) - 1UL;

        var totalBits = totalBlocks * bitsPerBlock;
        var longCount = (int)Math.Ceiling(totalBits / 64.0);
        var data = new long[longCount];

        var paletteIndexCache = new Dictionary<(string Id, string PropsKey), int>(palette.Colors.Length);
        for (var i = 0; i < palette.Colors.Length; i++)
        {
            var color = palette.Colors[i];
            var propsKey = GetPropertiesKey(color.Properties);
            paletteIndexCache[(color.Id, propsKey)] = i + 1;
        }

        for (var y = 0; y < height; y++)
        {
            for (var z = 0; z < depth; z++)
            {
                for (var x = 0; x < width; x++)
                {
                    var blockIndex = (y * depth + z) * width + x;

                    if (!byPos.TryGetValue((x, y, z), out var block)) block = new BlockInfo { Id = "minecraft:air", X = x, Y = y, Z = z, Properties = new Dictionary<string, string>() };

                    int paletteIndex;

                    if (block.Id == "minecraft:air")
                        paletteIndex = 0;
                    else
                    {
                        var propsKey = GetPropertiesKey(block.Properties);
                        if (!paletteIndexCache.TryGetValue((block.Id, propsKey), out paletteIndex))
                        {
                            throw new InvalidOperationException($"Block {block.Id} - [{propsKey}] not found in palette.");
                        }
                    }

                    var value = (ulong)paletteIndex & mask;
                    var bitIndex = blockIndex * bitsPerBlock;
                    var longIndex = bitIndex / 64;
                    var bitOffset = bitIndex % 64;

                    data[longIndex] |= (long)(value << bitOffset);

                    var bitsInCurrentLong = 64 - bitOffset;
                    if (bitsInCurrentLong < bitsPerBlock)
                    {
                        data[longIndex + 1] |= (long)(value >> bitsInCurrentLong);
                    }
                }
            }
        }

        return data;
    }


        private static string GetPropertiesKey(Dictionary<string, string> properties)
        {
            if (properties.Count == 0)
                return string.Empty;

            var sorted = properties.OrderBy(kv => kv.Key);
            return string.Join(";", sorted.Select(kv => $"{kv.Key}={kv.Value}"));
        }

        private static NbtCompound CreateMapCompound((int width, int height, int depth) dimensions, NbtList blockStatePalette, long[] blockStates) =>
            new NbtCompound("Map")
                .Add(blockStatePalette)
                .Add(new NbtLongArray("BlockStates", blockStates))
                .Add(new NbtList("Entities"))
                .Add(new NbtList("TileEntities"))
                .Add(new NbtList("PendingBlockTicks"))
                .Add(new NbtList("PendingFluidTicks"))
                .Add(new NbtCompound("Position")
                    .Add(new NbtInt("x", 0))
                    .Add(new NbtInt("y", 0))
                    .Add(new NbtInt("z", 0)))
                .Add(new NbtCompound("Size")
                    .Add(new NbtInt("x", dimensions.width))
                    .Add(new NbtInt("y", dimensions.height))
                    .Add(new NbtInt("z", dimensions.depth)));

        private static NbtCompound CreateRegionCompound(string regionName, (int width, int height, int depth) dimensions,
            NbtList blockStatePalette, long[] blockStates, int posX, int posY, int posZ)
        {
            return new NbtCompound(regionName)
                .Add(blockStatePalette)
                .Add(new NbtLongArray("BlockStates", blockStates))
                .Add(new NbtList("Entities"))
                .Add(new NbtList("TileEntities"))
                .Add(new NbtList("PendingBlockTicks"))
                .Add(new NbtList("PendingFluidTicks"))
                .Add(new NbtCompound("Position")
                    .Add(new NbtInt("x", posX))
                    .Add(new NbtInt("y", posY))
                    .Add(new NbtInt("z", posZ)))
                .Add(new NbtCompound("Size")
                    .Add(new NbtInt("x", dimensions.width))
                    .Add(new NbtInt("y", dimensions.height))
                    .Add(new NbtInt("z", dimensions.depth)));
        }

        public Stream SaveAsStreamWithRegions(Palette palette, BlockInfo[] mapBlocks, BlockInfo[] placeholderBlocks,
            int minX, int minZ, int regionWidthInBlocks, int regionHeightInBlocks, int regionsX, int regionsZ)
        {
            if (mapBlocks.Length == 0 && placeholderBlocks.Length == 0)
            {
                return SaveAsStream(palette, []);
            }

            var overallMinX = minX;
            var overallMaxX = mapBlocks.Length > 0 ? mapBlocks.Max(b => b.X) : minX;
            var overallMinZ = minZ;
            var overallMaxZ = mapBlocks.Length > 0 ? mapBlocks.Max(b => b.Z) : minZ;
            
            var allBlocksForY = mapBlocks.Concat(placeholderBlocks).ToArray();
            var overallMinY = allBlocksForY.Length > 0 ? allBlocksForY.Min(b => b.Y) : 0;
            var overallMaxY = allBlocksForY.Length > 0 ? allBlocksForY.Max(b => b.Y) : 0;

            var overallWidth = Math.Max(1, overallMaxX - overallMinX + 1);
            var overallDepth = Math.Max(1, overallMaxZ - overallMinZ + 1);
            var overallHeight = Math.Max(1, overallMaxY - overallMinY + 1);

            var regionsCompound = new NbtCompound("Regions");
            var totalBlocksCount = 0;
            var totalVolume = 0;
            var actualRegionCount = 0;

            var placeholderBlocksInRange = placeholderBlocks
                .Where(b => b.X >= overallMinX && b.X <= overallMaxX)
                .ToArray();

            for (var regionX = 0; regionX < regionsX; regionX++)
            {
                for (var regionZ = 0; regionZ < regionsZ; regionZ++)
                {
                    var regionWorldMinX = minX + regionX * regionWidthInBlocks;
                    var regionWorldMaxX = regionWorldMinX + regionWidthInBlocks - 1;
                    var regionWorldMinZ = minZ + regionZ * regionHeightInBlocks;
                    var regionWorldMaxZ = regionWorldMinZ + regionHeightInBlocks - 1;

                    regionWorldMaxX = Math.Min(regionWorldMaxX, overallMaxX);
                    regionWorldMaxZ = Math.Min(regionWorldMaxZ, overallMaxZ);

                    if (regionWorldMinX > regionWorldMaxX || regionWorldMinZ > regionWorldMaxZ)
                        continue;

                    var regionMapBlocks = mapBlocks
                        .Where(b => b.X >= regionWorldMinX && b.X <= regionWorldMaxX &&
                                    b.Z >= regionWorldMinZ && b.Z <= regionWorldMaxZ)
                        .ToArray();

                    var regionPlaceholderBlocks = placeholderBlocksInRange
                        .Where(b => b.X >= regionWorldMinX && b.X <= regionWorldMaxX)
                        .ToArray();

                    if (regionMapBlocks.Length == 0 && regionPlaceholderBlocks.Length == 0)
                        continue;

                    var regionWidthActual = regionWorldMaxX - regionWorldMinX + 1;
                    
                    var regionMapDepth = regionMapBlocks.Length > 0 
                        ? regionWorldMaxZ - regionWorldMinZ + 1
                        : 0;
                    var regionDepthActual = regionMapDepth + 1;
                    var regionHeightActual = Math.Max(1, overallHeight);
                    
                    if (regionWidthActual <= 0 || regionDepthActual <= 0)
                        continue;

                    var regionBlocksLocal = new List<BlockInfo>();

                    foreach (var pb in regionPlaceholderBlocks)
                    {
                        regionBlocksLocal.Add(new BlockInfo(
                            pb.X - regionWorldMinX,
                            pb.Y - overallMinY,
                            0,
                            pb.Id,
                            pb.Properties
                        ));
                    }

                    foreach (var mb in regionMapBlocks)
                    {
                        regionBlocksLocal.Add(new BlockInfo(
                            mb.X - regionWorldMinX,
                            mb.Y - overallMinY,
                            mb.Z - regionWorldMinZ + 1,
                            mb.Id,
                            mb.Properties
                        ));
                    }

                    var regionBlocksArray = regionBlocksLocal.ToArray();
                    var regionDimensions = (width: regionWidthActual, height: regionHeightActual, depth: regionDepthActual);
                    var regionPalette = CreateBlockStatePalette(palette);
                    var regionBlockStates = CreateBlockStates(regionBlocksArray, regionDimensions, palette);

                    var regionPosX = regionWorldMinX - overallMinX;
                    var regionPosY = 0;
                    var regionPosZ = regionWorldMinZ - overallMinZ;

                    var regionName = $"region_{regionX}_{regionZ}";
                    var regionCompound = CreateRegionCompound(regionName, regionDimensions, regionPalette, regionBlockStates, regionPosX, regionPosY, regionPosZ);

                    regionsCompound.Add(regionCompound);

                    totalBlocksCount += regionBlocksArray.Length;
                    totalVolume += regionDimensions.width * regionDimensions.height * regionDimensions.depth;
                    actualRegionCount++;
                }
            }

            var enclosingSize = new NbtCompound("EnclosingSize")
                .Add(new NbtInt("x", overallWidth))
                .Add(new NbtInt("y", overallHeight))
                .Add(new NbtInt("z", overallDepth));

            var timestamp = DateTimeOffset.UtcNow.ToUnixTimeMilliseconds();
            var metadata = new NbtCompound("Metadata")
                .Add(new NbtString("Name", "WaxMapArt"))
                .Add(new NbtString("Description", "Generated by WaxMapArt"))
                .Add(new NbtString("Author", "WaxMapArt"))
                .Add(enclosingSize)
                .Add(new NbtInt("RegionCount", actualRegionCount))
                .Add(new NbtLong("TimeCreated", timestamp))
                .Add(new NbtLong("TimeModified", timestamp))
                .Add(new NbtInt("TotalBlocks", totalBlocksCount))
                .Add(new NbtInt("TotalVolume", totalVolume));

            var file = new NbtFile();
            file.Root
                .Add(new NbtInt("Version", 7))
                .Add(new NbtInt("MinecraftDataVersion", 3955))
                .Add(metadata)
                .Add(regionsCompound);

            var rawStream = file.SerializeToStream();
            var ms = new MemoryStream();
            using (var gzip = new GZipStream(ms, CompressionMode.Compress, true))
            {
                rawStream.CopyTo(gzip);
                gzip.Flush();
            }
            rawStream.Close();
            rawStream.Dispose();
            ms.Seek(0, SeekOrigin.Begin);
            return ms;
        }

        public string GetFileFormat() => "litematic";
    }
}
