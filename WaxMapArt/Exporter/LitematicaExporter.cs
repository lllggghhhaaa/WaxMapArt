using System.IO.Compression;
using WaxMapArt.Entities;
using WaxNBT;
using WaxNBT.Tags;

namespace WaxMapArt.Exporter;

public class LitematicaExporter : IExporter
{
    public Stream SaveAsStream(Palette palette, BlockInfo[] blocks)
    {
        var dimensions = CalculateDimensions(blocks);

        var metadata = CreateMetadata(dimensions, blocks);
        var blockStatePalette = CreateBlockStatePalette(palette);
        var blockStates = CreateBlockStates(blocks, dimensions, palette);

        var map = CreateMapCompound(dimensions, blockStatePalette, blockStates);
        var regions = new NbtCompound("Regions").Add(map);

        var file = new NbtFile();
        file.Root
            .Add(metadata)
            .Add(regions)
            .Add(new NbtInt("MinecraftDataVersion", 3955))
            .Add(new NbtInt("Version", 7))
            .Add(new NbtInt("SubVersion", 1));

        var rawStream = file.SerializeToStream();
        var ms = new MemoryStream();
        using (var gzip = new GZipStream(ms, CompressionMode.Compress, true)) rawStream.CopyTo(gzip);
        rawStream.Close();
        ms.Seek(0, SeekOrigin.Begin);
        return ms;
    }

    private static (int width, int height, int depth) CalculateDimensions(BlockInfo[] blocks)
    {
        if (blocks.Length == 0) return (0, 0, 0);

        var (minX, maxX) = (blocks.Min(b => b.X), blocks.Max(b => b.X));
        var (minY, maxY) = (blocks.Min(b => b.Y), blocks.Max(b => b.Y));
        var (minZ, maxZ) = (blocks.Min(b => b.Z), blocks.Max(b => b.Z));

        return (maxX - minX + 1, maxY - minY + 1, maxZ - minZ + 1);
    }

    private static NbtCompound CreateMetadata((int width, int height, int depth) dimensions, BlockInfo[] blocks)
    {
        var enclosingSize = new NbtCompound("EnclosingSize")
            .Add(new NbtInt("x", dimensions.width))
            .Add(new NbtInt("y", dimensions.height))
            .Add(new NbtInt("z", dimensions.depth));

        var timestamp = DateTimeOffset.UtcNow.ToUnixTimeMilliseconds();

        return new NbtCompound("Metadata")
            .Add(new NbtString("Name", "WaxMapArt"))
            .Add(new NbtString("Description", "Generated by WaxMapArt"))
            .Add(new NbtString("Author", "WaxMapArt"))
            .Add(enclosingSize)
            .Add(new NbtInt("RegionCount", 1))
            .Add(new NbtLong("TimeCreated", timestamp))
            .Add(new NbtLong("TimeModified", timestamp))
            .Add(new NbtInt("TotalBlocks", blocks.Length))
            .Add(new NbtInt("TotalVolume", dimensions.width * dimensions.height * dimensions.depth));
    }

    private static NbtList CreateBlockStatePalette(Palette palette)
    {
        var list = new NbtList("BlockStatePalette");

        var airCompound = new NbtCompound().Add(new NbtString("Name", "minecraft:air"));
        list.Add(airCompound);

        foreach (var color in palette.Colors)
        {
            var comp = new NbtCompound()
                .Add(new NbtString("Name", color.Id));

            if (color.Properties.Count > 0)
            {
                var props = new NbtCompound("Properties");
                foreach (var kv in color.Properties.OrderBy(k => k.Key))
                    props.Add(new NbtString(kv.Key, kv.Value));
                comp.Add(props);
            }

            list.Add(comp);
        }

        return list;
    }

    private static long[] CreateBlockStates(BlockInfo[] blocks, (int width, int height, int depth) dimensions, Palette palette)
    {
        var width = dimensions.width;
        var height = dimensions.height;
        var depth = dimensions.depth;
        var totalBlocks = width * height * depth;

        var minX = blocks.Min(b => b.X);
        var minY = blocks.Min(b => b.Y);
        var minZ = blocks.Min(b => b.Z);
        var byPos = new Dictionary<(int x, int y, int z), BlockInfo>(blocks.Length);
        foreach (var b in blocks) byPos[(b.X - minX, b.Y - minY, b.Z - minZ)] = b;

        var paletteSize = palette.Colors.Length + 1;
        var bitsPerBlock = Math.Max(2, (int)Math.Ceiling(Math.Log2(paletteSize)));
        var mask = (1UL << bitsPerBlock) - 1UL;

        var totalBits = totalBlocks * bitsPerBlock;
        var longCount = (int)Math.Ceiling(totalBits / 64.0);
        var data = new long[longCount];

        var paletteIndexCache = new Dictionary<(string Id, string PropsKey), int>(palette.Colors.Length);
        for (var i = 0; i < palette.Colors.Length; i++)
        {
            var color = palette.Colors[i];
            var propsKey = GetPropertiesKey(color.Properties);
            paletteIndexCache[(color.Id, propsKey)] = i + 1;
        }

        for (var y = 0; y < height; y++)
        {
            for (var z = 0; z < depth; z++)
            {
                for (var x = 0; x < width; x++)
                {
                    var blockIndex = (y * depth + z) * width + x;

                    if (!byPos.TryGetValue((x, y, z), out var block)) block = new BlockInfo { Id = "minecraft:air", X = x, Y = y, Z = z, Properties = new Dictionary<string, string>() };

                    int paletteIndex;

                    if (block.Id == "minecraft:air")
                        paletteIndex = 0;
                    else
                    {
                        var propsKey = GetPropertiesKey(block.Properties);
                        if (!paletteIndexCache.TryGetValue((block.Id, propsKey), out paletteIndex))
                        {
                            throw new InvalidOperationException($"Block {block.Id} - [{propsKey}] not found in palette.");
                        }
                    }

                    var value = (ulong)paletteIndex & mask;
                    var bitIndex = blockIndex * bitsPerBlock;
                    var longIndex = bitIndex / 64;
                    var bitOffset = bitIndex % 64;

                    data[longIndex] |= (long)(value << bitOffset);

                    var bitsInCurrentLong = 64 - bitOffset;
                    if (bitsInCurrentLong < bitsPerBlock)
                    {
                        data[longIndex + 1] |= (long)(value >> bitsInCurrentLong);
                    }
                }
            }
        }

        return data;
    }

    private static string GetPropertiesKey(Dictionary<string, string> properties)
    {
        if (properties.Count == 0)
            return string.Empty;

        var sorted = properties.OrderBy(kv => kv.Key);
        return string.Join(";", sorted.Select(kv => $"{kv.Key}={kv.Value}"));
    }

    private static NbtCompound CreateMapCompound((int width, int height, int depth) dimensions, NbtList blockStatePalette, long[] blockStates) =>
        new NbtCompound("Map")
            .Add(blockStatePalette)
            .Add(new NbtLongArray("BlockStates", blockStates))
            .Add(new NbtList("Entities"))
            .Add(new NbtList("TileEntities"))
            .Add(new NbtList("PendingBlockTicks"))
            .Add(new NbtList("PendingFluidTicks"))
            .Add(new NbtCompound("Position")
                .Add(new NbtInt("x", 0))
                .Add(new NbtInt("y", 0))
                .Add(new NbtInt("z", 0)))
            .Add(new NbtCompound("Size")
                .Add(new NbtInt("x", dimensions.width))
                .Add(new NbtInt("y", dimensions.height))
                .Add(new NbtInt("z", dimensions.depth)));
}